<template>
  <ion-page>
    <!-- Header avec boutons -->
    <ion-header>
      <ion-toolbar>
        <ion-title>Signalements Routiers</ion-title>
        
        <!-- Filtre mes points -->
        <ion-buttons slot="start">
          <ion-button @click="toggleMyPoints" v-if="currentUser">
            <ion-icon :icon="filter" />
            {{ showOnlyMyPoints ? 'Tous' : 'Mes' }}
          </ion-button>
        </ion-buttons>
        
        <!-- Boutons droite -->
        <ion-buttons slot="end">
          <ion-button @click="centerOnMyLocation">
            <ion-icon :icon="locate" />
          </ion-button>
          
          <ion-button @click="toggleLogin" v-if="!currentUser">
            <ion-icon :icon="logIn" />
          </ion-button>
          
          <ion-button @click="logout" v-if="currentUser">
            <ion-icon :icon="logOut" />
          </ion-button>
        </ion-buttons>
      </ion-toolbar>
    </ion-header>
    
    <ion-content :fullscreen="true" class="ion-no-padding">
      <!-- Badge utilisateur -->
      <div v-if="currentUser" class="user-badge">
        <ion-chip color="primary">
          <ion-icon :icon="person" slot="start" />
          <ion-label>{{ currentUser.email }}</ion-label>
        </ion-chip>
      </div>
      
      <!-- Carte -->
      <div id="map-container"></div>
      
      <!-- Bouton pour ajouter un signalement -->
      <ion-fab vertical="bottom" horizontal="end" slot="fixed">
        <ion-fab-button @click="startAddReport" :disabled="!currentUser">
          <ion-icon :icon="add" />
        </ion-fab-button>
      </ion-fab>
      
      <!-- Modal de connexion -->
      <ion-modal :is-open="showLoginModal" @didDismiss="showLoginModal = false">
        <ion-header>
          <ion-toolbar>
            <ion-title>Connexion</ion-title>
            <ion-buttons slot="end">
              <ion-button @click="showLoginModal = false">
                <ion-icon :icon="close" />
              </ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        
        <ion-content class="ion-padding">
          <ion-item>
            <ion-label position="stacked">Email</ion-label>
            <ion-input v-model="loginEmail" type="email" placeholder="email@example.com" />
          </ion-item>
          
          <ion-item>
            <ion-label position="stacked">Mot de passe</ion-label>
            <ion-input v-model="loginPassword" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
          </ion-item>
          
          <ion-button expand="block" @click="doLogin" class="ion-margin-top">
            Se connecter
          </ion-button>
          
          <p v-if="loginError" class="error-message">{{ loginError }}</p>
          
          <ion-text color="medium" class="ion-text-center">
            <p class="ion-margin-top">Compte test: test@example.com / 123456</p>
          </ion-text>
        </ion-content>
      </ion-modal>
      
      <!-- Modal pour ajouter un signalement -->
      <ion-modal 
        :is-open="showAddReportModal" 
        @didDismiss="cancelAddReport"
        :initial-breakpoint="0.8"
        :breakpoints="[0, 0.8, 1]"
      >
        <ion-content>
          <ion-toolbar>
            <ion-title>Nouveau Signalement</ion-title>
            <ion-buttons slot="end">
              <ion-button @click="cancelAddReport">
                <ion-icon :icon="close" />
              </ion-button>
            </ion-buttons>
          </ion-toolbar>
          
          <ion-list class="ion-padding">
            <ion-item>
              <ion-label position="stacked">Lieu</ion-label>
              <ion-input :value="newReport.locationName" readonly />
            </ion-item>
            
            <ion-item>
              <ion-label position="stacked">Surface (m¬≤)</ion-label>
              <ion-input 
                v-model="newReport.surface" 
                type="number" 
                min="0" 
                step="0.1" 
                placeholder="Ex: 2.5" 
              />
            </ion-item>
            
            <ion-item>
              <ion-label position="stacked">Budget estim√© (‚Ç¨)</ion-label>
              <ion-input 
                v-model="newReport.budget" 
                type="number" 
                min="0" 
                step="1" 
                placeholder="Ex: 1500" 
              />
            </ion-item>
            
            <ion-item>
              <ion-label>Entreprise</ion-label>
              <ion-select 
                v-model="newReport.entrepriseId" 
                placeholder="S√©lectionner"
                interface="action-sheet"
              >
                <ion-select-option 
                  v-for="entreprise in entreprises" 
                  :key="entreprise.id" 
                  :value="entreprise.id"
                >
                  {{ entreprise.name }}
                </ion-select-option>
              </ion-select>
            </ion-item>
          </ion-list>
          
          <div class="ion-padding">
            <ion-button 
              expand="block" 
              @click="submitReport" 
              :disabled="!isReportValid"
            >
              Cr√©er le signalement
            </ion-button>
            
            <ion-button 
              expand="block" 
              fill="clear" 
              @click="cancelAddReport"
              class="ion-margin-top"
            >
              Annuler
            </ion-button>
          </div>
        </ion-content>
      </ion-modal>
    </ion-content>
  </ion-page>
</template>

<script setup lang="ts">
import {
  IonPage,
  IonHeader,
  IonToolbar,
  IonTitle,
  IonButtons,
  IonButton,
  IonIcon,
  IonContent,
  IonFab,
  IonFabButton,
  IonChip,
  IonLabel,
  IonModal,
  IonItem,
  IonInput,
  IonText,
  IonList,
  IonSelect,
  IonSelectOption,
  toastController,
  alertController,
  loadingController
} from '@ionic/vue';
import { 
  add, 
  locate, 
  filter, 
  person, 
  logIn, 
  logOut,
  close 
} from 'ionicons/icons';
import { onMounted, ref, onUnmounted, computed } from 'vue';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

// Services
import { getCurrentLocation, ANTANANARIVO_CENTER } from '@/services/locationService';
import { loginUser, logoutUser, onAuthChange, getCurrentUser } from '@/services/authService';
import { createPoint, getAllPoints, getMyPoints } from '@/services/pointService';

// Variables r√©actives
let map: L.Map | null = null;
let clickMarker: L.Marker | null = null;
const currentUser = ref<any>(null);
const showOnlyMyPoints = ref(false);
const showLoginModal = ref(false);
const showAddReportModal = ref(false);
const loginEmail = ref('');
const loginPassword = ref('');
const loginError = ref('');

// Donn√©es pour le nouveau signalement
const newReport = ref({
  lat: 0,
  lng: 0,
  locationName: '',
  surface: '',
  budget: '',
  entrepriseId: ''
});

// Liste des entreprises
const entreprises = ref([
  { id: '1', name: 'Colas' },
  { id: '2', name: 'Buildlab' },
  { id: '3', name: 'Voirie Tana' },
  { id: '4', name: 'Municipalit√©' }
]);

// Validation du formulaire
const isReportValid = computed(() => {
  return (
    newReport.value.surface &&
    newReport.value.budget &&
    newReport.value.entrepriseId &&
    parseFloat(newReport.value.surface) > 0 &&
    parseFloat(newReport.value.budget) > 0
  );
});

// Ic√¥ne pour les marqueurs
const createMarkerIcon = (isMine: boolean = false) => {
  const color = isMine ? '#007aff' : '#ff3b30';
  
  return L.divIcon({
    className: 'custom-marker',
    html: `
      <div style="
        background: ${color};
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 3px solid white;
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        cursor: pointer;
      "></div>
    `,
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });
};

// Initialiser la carte
const initMap = async () => {
  try {
    const pos = await getCurrentLocation();
    map = L.map('map-container').setView([pos.coords.latitude, pos.coords.longitude], 15);
  } catch {
    map = L.map('map-container').setView(ANTANANARIVO_CENTER, 13);
  }
  
  // Couche OpenStreetMap
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '¬© OpenStreetMap'
  }).addTo(map);
  
  // G√©rer les clics sur la carte
  map.on('click', async (e: L.LeafletMouseEvent) => {
    if (!currentUser.value) {
      showLoginModal.value = true;
      return;
    }
    
    // Nettoyer le marqueur pr√©c√©dent
    if (clickMarker) {
      map?.removeLayer(clickMarker);
      clickMarker = null;
    }
    
    // Ajouter un marqueur temporaire
    clickMarker = L.marker([e.latlng.lat, e.latlng.lng], {
      icon: createMarkerIcon(true),
      zIndexOffset: 1000
    }).addTo(map!);
    
    // R√©cup√©rer le nom du lieu
    const locationName = await getLocationName(e.latlng.lat, e.latlng.lng);
    
    // Pr√©parer les donn√©es pour le modal
    newReport.value = {
      lat: e.latlng.lat,
      lng: e.latlng.lng,
      locationName: locationName,
      surface: '',
      budget: '',
      entrepriseId: ''
    };
    
    // Afficher le modal
    showAddReportModal.value = true;
  });
  
  // Charger les points existants
  loadPoints();
};

// Charger les points
const loadPoints = async () => {
  if (!map) return;
  
  // Nettoyer les marqueurs existants (sauf le marqueur de clic)
  map.eachLayer((layer) => {
    if (layer instanceof L.Marker && layer !== clickMarker) {
      map?.removeLayer(layer);
    }
  });
  
  try {
    let result;
    
    if (showOnlyMyPoints.value && currentUser.value) {
      result = await getMyPoints();
    } else {
      result = await getAllPoints();
    }
    
    if (result.success) {
      result.points.forEach((point: any) => {
        const isMine = currentUser.value && point.userId === currentUser.value.id;
        addMarkerToMap(point, isMine);
      });
    }
  } catch (error) {
    console.error('Erreur chargement points:', error);
  }
};

// Ajouter un marqueur √† la carte
const addMarkerToMap = (point: any, isMine: boolean = false) => {
  if (!map) return;
  
  const marker = L.marker([point.latitude, point.longitude], {
    icon: createMarkerIcon(isMine)
  }).addTo(map);
  
  // Trouver le nom de l'entreprise
  const entreprise = entreprises.value.find(e => e.id === point.id_entreprise);
  const entrepriseName = entreprise ? entreprise.name : 'Inconnue';
  
  // Formater la date
  let dateFormatted = 'Date inconnue';
  if (point.createdAt) {
    if (point.createdAt.toDate) {
      dateFormatted = point.createdAt.toDate().toLocaleDateString('fr-FR');
    } else if (point.createdAt instanceof Date) {
      dateFormatted = point.createdAt.toLocaleDateString('fr-FR');
    }
  }
  
  // Contenu du popup
  const popupContent = `
    <div style="min-width: 250px; padding: 8px;">
      <strong style="color: ${isMine ? '#007aff' : '#ff3b30'}">
        ${point.nameplace} ${isMine ? '(√Ä moi)' : ''}
      </strong>
      <hr style="margin: 8px 0; border-color: #eee;">
      <div style="font-size: 14px;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
          <span>üìç Position:</span>
          <span>${point.latitude.toFixed(6)}, ${point.longitude.toFixed(6)}</span>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
          <span>üìè Surface:</span>
          <strong>${point.surface} m¬≤</strong>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
          <span>üí∞ Budget:</span>
          <strong>${point.budget} ‚Ç¨</strong>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
          <span>üè¢ Entreprise:</span>
          <strong>${entrepriseName}</strong>
        </div>
        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
          <span>üë§ Cr√©√© par:</span>
          <span>${point.userName || point.userEmail || 'Utilisateur'}</span>
        </div>
        <div style="display: flex; justify-content: space-between;">
          <span>üìÖ Date:</span>
          <small>${dateFormatted}</small>
        </div>
      </div>
    </div>
  `;
  
  marker.bindPopup(popupContent);
  
  // Ouvrir au survol sur mobile
  marker.on('mouseover', () => {
    marker.openPopup();
  });
  
  marker.on('mouseout', () => {
    marker.closePopup();
  });
};

const getLocationName = async (lat: number, lng: number): Promise<string> => {
  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`
    );
    const data = await response.json();
    return data.display_name || `Position (${lat.toFixed(4)}, ${lng.toFixed(4)})`;
  } catch {
    return `Position (${lat.toFixed(4)}, ${lng.toFixed(4)})`;
  }
};

// Actions utilisateur
const centerOnMyLocation = async () => {
  if (!map) return;
  
  try {
    const pos = await getCurrentLocation();
    map.setView([pos.coords.latitude, pos.coords.longitude], 16);
  } catch (error) {
    const alert = await alertController.create({
      header: 'Erreur',
      message: 'Localisation non disponible',
      buttons: ['OK']
    });
    await alert.present();
  }
};

const toggleMyPoints = () => {
  if (!currentUser.value) {
    showLoginModal.value = true;
    return;
  }
  
  showOnlyMyPoints.value = !showOnlyMyPoints.value;
  loadPoints();
};

const startAddReport = () => {
  if (!currentUser.value) {
    showLoginModal.value = true;
    return;
  }
  
  const alert = alertController.create({
    header: 'Ajouter un signalement',
    message: 'Cliquez sur la carte pour s√©lectionner l\'emplacement',
    buttons: ['OK']
  });
};

const cancelAddReport = () => {
  showAddReportModal.value = false;
  
  // Nettoyer le marqueur de clic
  if (clickMarker && map) {
    map.removeLayer(clickMarker);
    clickMarker = null;
  }
  
  // R√©initialiser le formulaire
  newReport.value = {
    lat: 0,
    lng: 0,
    locationName: '',
    surface: '',
    budget: '',
    entrepriseId: ''
  };
};

const submitReport = async () => {
  if (!isReportValid.value || !currentUser.value) return;
  
  const loading = await loadingController.create({
    message: 'Cr√©ation du signalement...'
  });
  await loading.present();
  
  try {
    // CORRECTION ICI : Ne pas inclure userId ni userName
    const result = await createPoint({
      latitude: newReport.value.lat,
      longitude: newReport.value.lng,
      surface: parseFloat(newReport.value.surface),
      budget: parseFloat(newReport.value.budget),
      id_entreprise: newReport.value.entrepriseId,
      nameplace: newReport.value.locationName
      // IMPORTANT : Pas de userId, userName ou userEmail ici !
      // Ces propri√©t√©s seront ajout√©es par pointService
    });
    
    if (result.success && result.point) {
      // Le point retourn√© par createPoint contient d√©j√† userId et userName
      addMarkerToMap(result.point, true);
      
      const toast = await toastController.create({
        message: 'Signalement cr√©√© avec succ√®s !',
        duration: 2000,
        color: 'success'
      });
      await toast.present();
      
      // Fermer le modal et nettoyer
      cancelAddReport();
    } else {
      throw new Error(result.error || 'Erreur inconnue');
    }
  } catch (error: any) {
    console.error('Erreur:', error);
    
    const alert = await alertController.create({
      header: 'Erreur',
      message: error.message || 'Impossible de cr√©er le signalement',
      buttons: ['OK']
    });
    await alert.present();
  } finally {
    await loading.dismiss();
  }
};

// Authentification
const toggleLogin = () => {
  showLoginModal.value = true;
};

const doLogin = async () => {
  if (!loginEmail.value || !loginPassword.value) {
    loginError.value = 'Veuillez remplir tous les champs';
    return;
  }
  
  const loading = await loadingController.create({
    message: 'Connexion...'
  });
  await loading.present();
  
  const result = await loginUser(loginEmail.value, loginPassword.value);
  
  await loading.dismiss();
  
  if (result.success) {
    currentUser.value = result.user;
    showLoginModal.value = false;
    loginError.value = '';
    loginEmail.value = '';
    loginPassword.value = '';
    
    // Recharger les points
    loadPoints();
  } else {
    loginError.value = result.error || 'Erreur de connexion';
  }
};

const logout = async () => {
  await logoutUser();
  currentUser.value = null;
  showOnlyMyPoints.value = false;
  loadPoints();
};

// Initialisation
onMounted(() => {
  initMap();
  
  // V√©rifier si d√©j√† connect√©
  currentUser.value = getCurrentUser();
  
  // √âcouter les changements d'auth
  const unsubscribe = onAuthChange((user) => {
    currentUser.value = user;
    if (user) {
      loadPoints();
    }
  });
  
  onUnmounted(() => {
    if (unsubscribe) unsubscribe();
    if (map) {
      map.remove();
      map = null;
    }
  });
});
</script>

<style scoped>
#map-container {
  width: 100%;
  height: 100vh;
}

.user-badge {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 1000;
  pointer-events: none;
}

.error-message {
  color: #ff3b30;
  text-align: center;
  margin-top: 15px;
}

/* Styles pour les popups */
:deep(.leaflet-popup-content) {
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  margin: 13px 19px;
}

:deep(.leaflet-popup-content-wrapper) {
  border-radius: 8px;
  box-shadow: 0 3px 14px rgba(0,0,0,0.4);
}

:deep(.leaflet-marker-icon) {
  cursor: pointer;
}

/* Ajustements pour mobile */
@media (max-width: 768px) {
  .user-badge {
    top: 60px;
  }
  
  :deep(.leaflet-popup) {
    max-width: 280px !important;
  }
}
</style>